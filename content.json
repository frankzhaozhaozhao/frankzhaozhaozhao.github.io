{"pages":[{"title":"","text":"ğŸ‰ åªæ˜¯ä¸ºäº†è®°å½• Just for Recording ä¸€ä¸ªç®€å•çš„Blogï¼Œè®°å½•ä¸€äº›LeetCodeé¢˜ç›®çš„æ€è·¯ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°éœ€è¦å¸®åŠ©çš„äººã€‚ A simple blog just for recording some LeetCode questions, hope it helps.","link":"/about/index.html"}],"posts":[{"title":"1722. Minimize Hamming Distance After Swap Operations","text":"ğŸ“¦ Refresh Your MemoryGiven a source array and a target array with an allowedSwaps array where each allowedSwaps[i] = [ai, bi]. Find the minimum hamming distance after unlimited swaps. ğŸ“š Key Notes The detail of how it swaps does not matter If we can swap [0, 1] and [1, 2], then we can rearrange [0, 1, 2] to everything we want. Similar question: 1202. Smallest String With Swaps Thus, union-find would be a good fit Steps: Union-find all connected indexes Count elements for each union-find group (we use Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; here) Scan the target, try to find the element in that union-find group greedily if found: count - 1 if not: diff + 1 ğŸ’» Codepublic int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int N = source.length; int[] UNION = new int[N]; for (int i = 0; i &lt; N; ++i) UNION[i] = i; // union-find for (int[] swap : allowedSwaps) { int indexA = swap[0], indexB = swap[1]; int parentA = find(UNION, indexA), parentB = find(UNION, indexB); // union A and B if (parentA != parentB) UNION[parentA] = parentB; } // count element for each union-find group -&gt; key: root of each union group, value: map Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; N; ++i) { int num = source[i]; int root = find(UNION, i); map.putIfAbsent(root, new HashMap&lt;&gt;()); Map&lt;Integer, Integer&gt; store = map.get(root); store.put(num, store.getOrDefault(num, 0) + 1); } // greedy fit the target, if not, diff++ int res = 0; for (int i = 0; i &lt; N; ++i) { int num = target[i]; int root = find(UNION, i); Map&lt;Integer, Integer&gt; store = map.get(root); if (store.getOrDefault(num, 0) == 0) res++; else store.put(num, store.get(num) - 1); } return res;}// union-find helperprivate int find(int[] UNION, int node) { if (UNION[node] == node) return node; return UNION[node] = find(UNION, UNION[node]);} ğŸ‰ ThoughtsThis kind of unlimited swaps, steps, etc problems (do not care the process but result) ususally can be solved by union-find.","link":"/2021/01/21/1722-Minimize-Hamming-Distance-After-Swap-Operations/"},{"title":"1723. Find Minimum Time to Finish All Jobs","text":"ğŸ“¦ Refresh Your MemoryYou are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job. And given the k workers, return the minimum possible maximum working time of any assignment. ğŸ“š Key Notes Classic DP problem, can be solved easily by using top-down dp (dfs + memo) BUT we need some optimizations to avoid TLE It is a common technique called â€œsymmetry breakingâ€. (1) Pick the biggest job first (2) If current max is larger than our res, just exit peacefully (3) If multiple workers have the same values, assigning current job to either one has the same effect. Apart from the dp solution, we could also do it with binary search. We will search minimum time result from 0 to sum(jobs) (means: assign all jobs to single one worker, brutal). When doing the valid check: we need to do it recursively. Try to assign each job to each worker (something like permutation). ğŸ’» CodeDP Solutionint res = Integer.MAX_VALUE; public int minimumTimeRequired(int[] jobs, int k) { Arrays.sort(jobs); helper(jobs, jobs.length - 1, new int[k]); return res;}private void helper(int[] jobs, int index, int[] sum) { if (index &lt; 0) { res = Math.min(res, Arrays.stream(sum).max().getAsInt()); return; } if (Arrays.stream(sum).max().getAsInt() &gt;= res) return; // early exit for (int i = 0; i &lt; sum.length; ++i) { if (i &gt; 0 &amp;&amp; sum[i] == sum[i - 1]) continue; // only search 1 sum[i] += jobs[index]; helper(jobs, index - 1, sum); sum[i] -= jobs[index]; }} Binary Search Solutionpublic int minimumTimeRequired(int[] jobs, int k) { Arrays.sort(jobs); int res = -1; int l = 0, r = Arrays.stream(jobs).sum(); while (l &lt;= r) { int m = (r - l) / 2 + l; int[] sum = new int[k]; if (isValid(jobs, sum, m, 0)) { res = m; r = m - 1; } else { l = m + 1; } } return res;}private boolean isValid(int[] jobs, int[] sum, int target, int index) { if (index == jobs.length) return true; for (int i = 0; i &lt; sum.length; ++i) { sum[i] += jobs[index]; if (sum[i] &lt;= target &amp;&amp; isValid(jobs, sum, target, index + 1)) return true; sum[i] -= jobs[index]; if (sum[i] == 0) break; // 0 is not possible, then no need to check anymore } return false;} ğŸ‰ ThoughtsWhen doing hard dp problem, apart from dfs/memo, think about more optimizations like sorting, cut branch, etc.","link":"/2021/01/21/1723-Find-Minimum-Time-to-Finish-All-Jobs/"},{"title":"1726. Tuple with Same Product","text":"ğŸ“¦ Refresh Your MemoryGiven an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d. ğŸ“š Key Notes Naive way is O(N^4), just try each tuple and check. Based on the data constraints, will TLE. Further more, we could do it in O(N^3) by sorting, somehome like binary search, but still will TLE as expected. By fixing two points (one tuple), we use two pointers to shrink and keep searching the other tuple. if l * r is larger than the product of two points, shrink r. Otherwise, move l. Based on the description, every element is distinct: we could simply use map and count tuple product and its frequency, which leads to the O(N^2) solution. If tuple (a, b) and (c, d) both have the same product: that means a, b, c, d they are all different for sure. Based on this, we could pre-compute the map first to get product with frequency, and then, go through every map entry to calculate the result. Here, we use math to calculate that: (1 + 2 + 3 + â€¦ + n) = (1 + n) * n / 2 ğŸ’» CodeO(N^3) Solutionint N = nums.length;Arrays.sort(nums);int res = 0;for (int i = 0; i &lt; N; ++i) { for (int j = N - 1; j &gt;= i + 3; --j) { int product = nums[i] * nums[j]; int l = i + 1, r = j - 1; while (l &lt; r) { int value = nums[l] * nums[r]; if (value == product) { ++l; --r; res += 8; } else if (value &gt; product) --r; else ++l; } }}return res; O(N^2) SolutionMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();int N = nums.length;for (int i = 0; i &lt; N; ++i) { for (int j = i + 1; j &lt; N; ++j) { int p = nums[i] * nums[j]; map.put(p, map.getOrDefault(p, 0) + 1); }}int res = 0;for (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) { if (e.getValue() &lt;= 1) continue; int count = e.getValue(); res += (8 * ((1 + count - 1) * (count - 1) / 2));}return res; ğŸ‰ Thoughts Check the data constrains first to have a general idea, what time complexity is required.","link":"/2021/01/18/1726-Tuple-with-Same-Product/"},{"title":"1727. Largest Submatrix With Rearrangements","text":"ğŸ“¦ Refresh Your MemoryYou are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order. Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally. ğŸ“š Key Notes These kinds of problems(binary matrix, submatrix area, etc) can generally be solved by trying just all possibilities. We could try to search for every down-side row (åº•è¾¹). For each down-side row, we can first calculate the histogram for this row. Then, a simple sort will solve the problem. Once sorting the histogram, for each histogram column, the area it can form is: Height: the value of the histogram column Width: N - the index of the histogram column The best way to think about this question is to draw. ğŸ’» Codeint M = matrix.length, N = matrix[0].length; int[] A = new int[N]; // histogramint res = 0;for (int down = 0; down &lt; M; ++down) { // compute histogram for this down-side row for (int j = 0; j &lt; N; ++j) { A[j] = matrix[down][j] == 1 ? A[j] + 1 : 0; } // sort and compute max int[] B = Arrays.copyOf(A, A.length); Arrays.sort(B); for (int k = 0; k &lt; N; ++k) { int area = B[k] * (N - k); // B[k]: height, (N - k): width res = Math.max(res, area); }}return res; ğŸ‰ Thoughts Largest area, submetrix, histogramâ€¦æ‹¿åˆ°ç±»ä¼¼çš„é¢˜ç›®å°±å»æƒ³ä¸€æƒ³up/down rowè¯•æ¯ä¸€ç§å¯èƒ½æ€§è¿™ç§æ–¹æ³•ã€‚","link":"/2021/01/18/1727-Largest-Submatrix-With-Rearrangements/"},{"title":"1728. Cat and Mouse II","text":"ğŸ“¦ Refresh Your MemoryA game is played by a cat and a mouse named Cat and Mouse with some rules and constraints. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. ğŸ“š Key Notes DFS/Memo part is simple. Just follow the standard of the top down dp. We should distinguish the turn for mouse and cat. For mouse: we are trying to find a way to win -&gt; if there is a true, we just return true For cat: we are trying to find a way to not let mouse win -&gt; if there is a false, we just return false. And, we have 5 variables in dfs, thus, create a 5D DP to memo it. The key to pass this question is: there is a case, cat and mouse they both can not proceed (live lock). Based on some tests, this magic number is 68. That means, if we run over 68 times, cat wins! ğŸ’» Codeprivate char[][] A; private int M, N;private int[] dirs = new int[] {1, 0, -1, 0, 1};private int maxCat, maxMouse;private int MAGIC_NUMBER = 68;public boolean canMouseWin(String[] grid, int catJump, int mouseJump) { M = grid.length; N = grid[0].length(); A = new char[M][N]; maxCat = catJump; maxMouse = mouseJump; for (int i = 0; i &lt; M; ++i) { A[i] = grid[i].toCharArray(); } int[] catPos = new int[2]; int[] mousePos = new int[2]; for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { if (A[i][j] == 'C') catPos = new int[] {i, j}; if (A[i][j] == 'M') mousePos = new int[] {i, j}; } } return helper(catPos[0], catPos[1], mousePos[0], mousePos[1], 0, new Boolean[8][8][8][8][MAGIC_NUMBER]);}// helper means: does mouse win?private boolean helper(int cx, int cy, int mx, int my, int turn, Boolean[][][][][] dp) { // the game will ends in ~ 68 rounds, let's safe it to 200 rounds if (turn &gt;= MAGIC_NUMBER) return false; if (mx == cx &amp;&amp; my == cy) return false; // memo cache if (dp[cx][cy][mx][my][turn] != null) return dp[cx][cy][mx][my][turn]; boolean res = !(turn % 2 == 0); // trick point if (turn % 2 == 0) { // mouse turn for (int d = 0; d &lt; 4; ++d) { if (res) break; for (int jump = 0; jump &lt;= maxMouse; ++jump) { int nx = mx + dirs[d] * jump; int ny = my + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = true; break; } if (helper(cx, cy, nx, ny, turn + 1, dp)) { res = true; break; } } } } else { // cat turn for (int d = 0; d &lt; 4; ++d) { if (!res) break; for (int jump = 0; jump &lt;= maxCat; ++jump) { int nx = cx + dirs[d] * jump; int ny = cy + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = false; break; } if (!helper(nx, ny, mx, my, turn + 1, dp)) { res = false; break; } } } } return dp[cx][cy][mx][my][turn] = res;}","link":"/2021/01/18/1728-Cat-and-Mouse-II/"}],"tags":[{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"Union Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Hard","slug":"Hard","link":"/tags/Hard/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Histogram","slug":"Histogram","link":"/tags/Histogram/"},{"name":"DFS&#x2F;Memo","slug":"DFS-Memo","link":"/tags/DFS-Memo/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}