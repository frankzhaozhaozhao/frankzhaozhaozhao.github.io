{"pages":[{"title":"","text":"🎉 只是为了记录 Just for Recording 一个简单的Blog，记录一些LeetCode题目的思路，希望能帮助到需要帮助的人。 A simple blog just for recording some LeetCode questions, hope it helps.","link":"/about/index.html"}],"posts":[{"title":"1727. Largest Submatrix With Rearrangements","text":"📦 Refresh Your MemoryYou are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order. Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally. 📚 Key Notes These kinds of problems(binary matrix, submatrix area, etc) can generally be solved by trying just all possibilities. We could try to search for every down-side row (底边). For each down-side row, we can first calculate the histogram for this row. Then, a simple sort will solve the problem. Once sorting the histogram, for each histogram column, the area it can form is: Height: the value of the histogram column Width: N - the index of the histogram column The best way to think about this question is to draw. 💻 Codeint M = matrix.length, N = matrix[0].length; int[] A = new int[N]; // histogramint res = 0;for (int down = 0; down &lt; M; ++down) { // compute histogram for this down-side row for (int j = 0; j &lt; N; ++j) { A[j] = matrix[down][j] == 1 ? A[j] + 1 : 0; } // sort and compute max int[] B = Arrays.copyOf(A, A.length); Arrays.sort(B); for (int k = 0; k &lt; N; ++k) { int area = B[k] * (N - k); // B[k]: height, (N - k): width res = Math.max(res, area); }}return res; 🎉 Thoughts Largest area, submetrix, histogram…拿到类似的题目就去想一想up/down row试每一种可能性这种方法。","link":"/2021/01/18/1727-Largest-Submatrix-With-Rearrangements/"},{"title":"1726. Tuple with Same Product","text":"📦 Refresh Your MemoryGiven an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d. 📚 Key Notes Naive way is O(N^4), just try each tuple and check. Based on the data constraints, will TLE. Further more, we could do it in O(N^3) by sorting, somehome like binary search, but still will TLE as expected. By fixing two points (one tuple), we use two pointers to shrink and keep searching the other tuple. if l * r is larger than the product of two points, shrink r. Otherwise, move l. Based on the description, every element is distinct: we could simply use map and count tuple product and its frequency, which leads to the O(N^2) solution. If tuple (a, b) and (c, d) both have the same product: that means a, b, c, d they are all different for sure. Based on this, we could pre-compute the map first to get product with frequency, and then, go through every map entry to calculate the result. Here, we use math to calculate that: (1 + 2 + 3 + … + n) = (1 + n) * n / 2 💻 CodeO(N^3) Solutionint N = nums.length;Arrays.sort(nums);int res = 0;for (int i = 0; i &lt; N; ++i) { for (int j = N - 1; j &gt;= i + 3; --j) { int product = nums[i] * nums[j]; int l = i + 1, r = j - 1; while (l &lt; r) { int value = nums[l] * nums[r]; if (value == product) { ++l; --r; res += 8; } else if (value &gt; product) --r; else ++l; } }}return res; O(N^2) SolutionMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();int N = nums.length;for (int i = 0; i &lt; N; ++i) { for (int j = i + 1; j &lt; N; ++j) { int p = nums[i] * nums[j]; map.put(p, map.getOrDefault(p, 0) + 1); }}int res = 0;for (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) { if (e.getValue() &lt;= 1) continue; int count = e.getValue(); res += (8 * ((1 + count - 1) * (count - 1) / 2));}return res; 🎉 Thoughts Check the data constrains first to have a general idea, what time complexity is required.","link":"/2021/01/18/1726-Tuple-with-Same-Product/"},{"title":"1728. Cat and Mouse II","text":"📦 Refresh Your MemoryA game is played by a cat and a mouse named Cat and Mouse with some rules and constraints. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. 📚 Key Notes DFS/Memo part is simple. Just follow the standard of the top down dp. We should distinguish the turn for mouse and cat. For mouse: we are trying to find a way to win -&gt; if there is a true, we just return true For cat: we are trying to find a way to not let mouse win -&gt; if there is a false, we just return false. And, we have 5 variables in dfs, thus, create a 5D DP to memo it. The key to pass this question is: there is a case, cat and mouse they both can not proceed (live lock). Based on some tests, this magic number is 68. That means, if we run over 68 times, cat wins! 💻 Codeprivate char[][] A; private int M, N;private int[] dirs = new int[] {1, 0, -1, 0, 1};private int maxCat, maxMouse;private int MAGIC_NUMBER = 68;public boolean canMouseWin(String[] grid, int catJump, int mouseJump) { M = grid.length; N = grid[0].length(); A = new char[M][N]; maxCat = catJump; maxMouse = mouseJump; for (int i = 0; i &lt; M; ++i) { A[i] = grid[i].toCharArray(); } int[] catPos = new int[2]; int[] mousePos = new int[2]; for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { if (A[i][j] == 'C') catPos = new int[] {i, j}; if (A[i][j] == 'M') mousePos = new int[] {i, j}; } } return helper(catPos[0], catPos[1], mousePos[0], mousePos[1], 0, new Boolean[8][8][8][8][MAGIC_NUMBER]);}// helper means: does mouse win?private boolean helper(int cx, int cy, int mx, int my, int turn, Boolean[][][][][] dp) { // the game will ends in ~ 68 rounds, let's safe it to 200 rounds if (turn &gt;= MAGIC_NUMBER) return false; if (mx == cx &amp;&amp; my == cy) return false; // memo cache if (dp[cx][cy][mx][my][turn] != null) return dp[cx][cy][mx][my][turn]; boolean res = !(turn % 2 == 0); // trick point if (turn % 2 == 0) { // mouse turn for (int d = 0; d &lt; 4; ++d) { if (res) break; for (int jump = 0; jump &lt;= maxMouse; ++jump) { int nx = mx + dirs[d] * jump; int ny = my + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = true; break; } if (helper(cx, cy, nx, ny, turn + 1, dp)) { res = true; break; } } } } else { // cat turn for (int d = 0; d &lt; 4; ++d) { if (!res) break; for (int jump = 0; jump &lt;= maxCat; ++jump) { int nx = cx + dirs[d] * jump; int ny = cy + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = false; break; } if (!helper(nx, ny, mx, my, turn + 1, dp)) { res = false; break; } } } } return dp[cx][cy][mx][my][turn] = res;}","link":"/2021/01/18/1728-Cat-and-Mouse-II/"}],"tags":[{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Histogram","slug":"Histogram","link":"/tags/Histogram/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"DFS&#x2F;Memo","slug":"DFS-Memo","link":"/tags/DFS-Memo/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Hard","slug":"Hard","link":"/tags/Hard/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}