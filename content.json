{"pages":[{"title":"","text":"ğŸ‰ åªæ˜¯ä¸ºäº†è®°å½• Just for Recording ä¸€ä¸ªç®€å•çš„Blogï¼Œè®°å½•ä¸€äº›LeetCodeé¢˜ç›®çš„æ€è·¯ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°éœ€è¦å¸®åŠ©çš„äººã€‚ A simple blog just for recording some LeetCode questions, hope it helps.","link":"/about/index.html"}],"posts":[{"title":"1727. Largest Submatrix With Rearrangements","text":"ğŸ“¦ Refresh Your MemoryYou are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order. Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally. ğŸ“š Key Notes These kinds of problems(binary matrix, submatrix area, etc) can generally be solved by trying just all possibilities. We could try to search for every down-side row (åº•è¾¹). For each down-side row, we can first calculate the histogram for this row. Then, a simple sort will solve the problem. Once sorting the histogram, for each histogram column, the area it can form is: Height: the value of the histogram column Width: N - the index of the histogram column The best way to think about this question is to draw. ğŸ’» Codeint M = matrix.length, N = matrix[0].length; int[] A = new int[N]; // histogramint res = 0;for (int down = 0; down &lt; M; ++down) { // compute histogram for this down-side row for (int j = 0; j &lt; N; ++j) { A[j] = matrix[down][j] == 1 ? A[j] + 1 : 0; } // sort and compute max int[] B = Arrays.copyOf(A, A.length); Arrays.sort(B); for (int k = 0; k &lt; N; ++k) { int area = B[k] * (N - k); // B[k]: height, (N - k): width res = Math.max(res, area); }}return res; ğŸ‰ Thoughts Largest area, submetrix, histogramâ€¦æ‹¿åˆ°ç±»ä¼¼çš„é¢˜ç›®å°±å»æƒ³ä¸€æƒ³up/down rowè¯•æ¯ä¸€ç§å¯èƒ½æ€§è¿™ç§æ–¹æ³•ã€‚","link":"/2021/01/18/1727-Largest-Submatrix-With-Rearrangements/"},{"title":"1726. Tuple with Same Product","text":"ğŸ“¦ Refresh Your MemoryGiven an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d. ğŸ“š Key Notes Naive way is O(N^4), just try each tuple and check. Based on the data constraints, will TLE. Further more, we could do it in O(N^3) by sorting, somehome like binary search, but still will TLE as expected. By fixing two points (one tuple), we use two pointers to shrink and keep searching the other tuple. if l * r is larger than the product of two points, shrink r. Otherwise, move l. Based on the description, every element is distinct: we could simply use map and count tuple product and its frequency, which leads to the O(N^2) solution. If tuple (a, b) and (c, d) both have the same product: that means a, b, c, d they are all different for sure. Based on this, we could pre-compute the map first to get product with frequency, and then, go through every map entry to calculate the result. Here, we use math to calculate that: (1 + 2 + 3 + â€¦ + n) = (1 + n) * n / 2 ğŸ’» CodeO(N^3) Solutionint N = nums.length;Arrays.sort(nums);int res = 0;for (int i = 0; i &lt; N; ++i) { for (int j = N - 1; j &gt;= i + 3; --j) { int product = nums[i] * nums[j]; int l = i + 1, r = j - 1; while (l &lt; r) { int value = nums[l] * nums[r]; if (value == product) { ++l; --r; res += 8; } else if (value &gt; product) --r; else ++l; } }}return res; O(N^2) SolutionMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();int N = nums.length;for (int i = 0; i &lt; N; ++i) { for (int j = i + 1; j &lt; N; ++j) { int p = nums[i] * nums[j]; map.put(p, map.getOrDefault(p, 0) + 1); }}int res = 0;for (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) { if (e.getValue() &lt;= 1) continue; int count = e.getValue(); res += (8 * ((1 + count - 1) * (count - 1) / 2));}return res; ğŸ‰ Thoughts Check the data constrains first to have a general idea, what time complexity is required.","link":"/2021/01/18/1726-Tuple-with-Same-Product/"},{"title":"1728. Cat and Mouse II","text":"ğŸ“¦ Refresh Your MemoryA game is played by a cat and a mouse named Cat and Mouse with some rules and constraints. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. ğŸ“š Key Notes DFS/Memo part is simple. Just follow the standard of the top down dp. We should distinguish the turn for mouse and cat. For mouse: we are trying to find a way to win -&gt; if there is a true, we just return true For cat: we are trying to find a way to not let mouse win -&gt; if there is a false, we just return false. And, we have 5 variables in dfs, thus, create a 5D DP to memo it. The key to pass this question is: there is a case, cat and mouse they both can not proceed (live lock). Based on some tests, this magic number is 68. That means, if we run over 68 times, cat wins! ğŸ’» Codeprivate char[][] A; private int M, N;private int[] dirs = new int[] {1, 0, -1, 0, 1};private int maxCat, maxMouse;private int MAGIC_NUMBER = 68;public boolean canMouseWin(String[] grid, int catJump, int mouseJump) { M = grid.length; N = grid[0].length(); A = new char[M][N]; maxCat = catJump; maxMouse = mouseJump; for (int i = 0; i &lt; M; ++i) { A[i] = grid[i].toCharArray(); } int[] catPos = new int[2]; int[] mousePos = new int[2]; for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { if (A[i][j] == 'C') catPos = new int[] {i, j}; if (A[i][j] == 'M') mousePos = new int[] {i, j}; } } return helper(catPos[0], catPos[1], mousePos[0], mousePos[1], 0, new Boolean[8][8][8][8][MAGIC_NUMBER]);}// helper means: does mouse win?private boolean helper(int cx, int cy, int mx, int my, int turn, Boolean[][][][][] dp) { // the game will ends in ~ 68 rounds, let's safe it to 200 rounds if (turn &gt;= MAGIC_NUMBER) return false; if (mx == cx &amp;&amp; my == cy) return false; // memo cache if (dp[cx][cy][mx][my][turn] != null) return dp[cx][cy][mx][my][turn]; boolean res = !(turn % 2 == 0); // trick point if (turn % 2 == 0) { // mouse turn for (int d = 0; d &lt; 4; ++d) { if (res) break; for (int jump = 0; jump &lt;= maxMouse; ++jump) { int nx = mx + dirs[d] * jump; int ny = my + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = true; break; } if (helper(cx, cy, nx, ny, turn + 1, dp)) { res = true; break; } } } } else { // cat turn for (int d = 0; d &lt; 4; ++d) { if (!res) break; for (int jump = 0; jump &lt;= maxCat; ++jump) { int nx = cx + dirs[d] * jump; int ny = cy + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = false; break; } if (!helper(nx, ny, mx, my, turn + 1, dp)) { res = false; break; } } } } return dp[cx][cy][mx][my][turn] = res;}","link":"/2021/01/18/1728-Cat-and-Mouse-II/"}],"tags":[{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Histogram","slug":"Histogram","link":"/tags/Histogram/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"DFS&#x2F;Memo","slug":"DFS-Memo","link":"/tags/DFS-Memo/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Hard","slug":"Hard","link":"/tags/Hard/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}