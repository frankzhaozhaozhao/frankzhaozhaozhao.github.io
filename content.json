{"pages":[{"title":"","text":"🎉 只是为了记录 Just for Recording 一个简单的Blog，记录一些LeetCode题目的思路，希望能帮助到需要帮助的人。 A simple blog just for recording some LeetCode questions, hope it helps.","link":"/about/index.html"}],"posts":[{"title":"1711. Count Good Meals","text":"📦 Refresh Your MemoryA good story, but it is just: giving an array, and return the number of different tuple (sum is power of 2) you can make from this list with MOD. 📚 Key Notes Firstly, check the data constraints: the sum of any two elements will be smaller than the Integer MAX. This kind of “Power of 2” problem usually can be solved with some O(32 Whatever) solution. That means: in terms of unsigned int, we only have 32 numbers which are power of two. Then, just search all of “power of 2” values with map (similar idea with two sum problem) 💻 Codeint MOD = (int) (1e9 + 7);int res = 0;for (int i = 0; i &lt; 32; ++i) { int target = 1 &lt;&lt; i; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int d : deliciousness) { if (target &gt;= d &amp;&amp; map.containsKey(target - d)) res = (res + map.get(target - d) % MOD) % MOD; map.put(d, map.getOrDefault(d, 0) + 1); }}return res; 🎉 ThoughtsWhen comes to power of 2, think about O(32 Whatever) solution.","link":"/2021/01/22/1711-Count-Good-Meals/"},{"title":"1712. Ways to Split Array Into Three Subarrays","text":"📦 Refresh Your MemorySplit an array to left, mid, and right with condition: the sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right. Return the number of good ways to split nums with MOD. 📚 Key Notes Naive solution would be: O(N^2), searching all two points, which separates leftSum, midSum and rightSum To quickly find the range sum, we will use prefix sum here (10^4 * 10^5 not out of bound of Integer, we good) By fixing one point (A), we could use binary search to find another point (B). If the point B is too left, the midSum will be too small If the point B is too right, the rightSum will be too small Basically, we are finding a range of the point B, which satisfies the condition (leftSum &lt;= midSum &lt;= rightSum) Similar the to question 34. Find First and Last Position of Element in Sorted Array 💻 Codepublic int waysToSplit(int[] nums) { int MOD = (int) (1e9 + 7); int N = nums.length; // prefix array int[] A = new int[N]; A[0] = nums[0]; for (int i = 1; i &lt; N; ++i) A[i] = A[i - 1] + nums[i]; int res = 0; for (int i = 1; i &lt; N - 1; ++i) { if (A[i - 1] &gt; (A[N - 1] - A[i - 1]) / 2) break; // early termination int left = helper(A, A[i - 1], i, true); int right = helper(A, A[i - 1], i, false); if (left == -1 || right == -1) continue; // none is satisfied res = (res + (right - left + 1) % MOD) % MOD; } return res;}private int helper(int[] A, int leftSum, int index, boolean searchLeft) { int N = A.length; int l = index, r = N - 2; int res = -1; while (l &lt;= r) { int m = (r - l) / 2 + l; int midSum = A[m] - A[index - 1]; int rightSum = A[N - 1] - A[m]; if (leftSum &lt;= midSum &amp;&amp; midSum &lt;= rightSum) { res = m; if (searchLeft) r = m - 1; else l = m + 1; } else if (leftSum &gt; midSum) { // shrink left l = m + 1; } else { // shrink right r = m - 1; } } return res;} 🎉 ThoughtsFrom naive to fairly good.","link":"/2021/01/22/1712-Ways-to-Split-Array-Into-Three-Subarrays/"},{"title":"1713. Minimum Operations to Make a Subsequence","text":"📦 Refresh Your MemoryYou are given an array target that consists of distinct integers and another integer array arr that can have duplicates. Keep inserting any element at any position into arr. Return the minimum number of operations needed to make target a subsequence of arr. 📚 Key Notes The problem seems like a LIS (longest increasing subsequence) problem, and it is. But based on the data constraints: O(N^2) will not be acceptable There are two ways to solve this problem: O(NlogN) LIS Solution, you could find it on LeetCode BIT (Binary Indexed Tree/Fenwich Tree) By using BIT, at each element of arr, we are looking for the longest subsequence value from its previous index. Normally, there are two methods for BIT: update and getPrefix. Just need to slightly modify both of them: not get sum but look for max. 💻 Codepublic int minOperations(int[] target, int[] arr) { int M = target.length, N = arr.length; int[] BIT = new int[M + 1]; // 1: index Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; M; ++i) { map.put(target[i], i); } int res = 0; for (int a : arr) { if (!map.containsKey(a)) continue; int index = map.get(a); int cur = getPreMax(BIT, index); cur++; res = Math.max(res, cur); update(BIT, index + 1, cur); } return M - res;}private void update(int[] BIT, int index, int val) { while (index &lt; BIT.length) { BIT[index] = Math.max(val, BIT[index]); index += index &amp; (-index); }}private int getPreMax(int[] BIT, int index) { int res = 0; while (index &gt; 0) { res = Math.max(res, BIT[index]); index -= index &amp; (-index); } return res;} 🎉 ThoughtsBIT usually works for finding range sun with frequent updates. But here, we are turning it to find max with frequent updates. It is just a derivative of BIT.","link":"/2021/01/22/1713-Minimum-Operations-to-Make-a-Subsequence/"},{"title":"1721. Swapping Nodes in a Linked List","text":"📦 Refresh Your MemoryYou are given the head of a linked list, and an integer k. Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed). 📚 Key Notes 3 passes solution is easy, find the Kth, find the N-Kth, and swap the values. 1 pass solution: Something like two pointers, put we actually move two pointers together. Find the k-th node, set a pointer (n2), and set another pointer at the head (n1) Move two pointers together until reaching the end. n1 and n2 are the onces we are looking for! 💻 CodeListNode n1 = null, n2 = null;ListNode node = head;// find the k-thfor (int i = 1; i &lt; k; ++i) { node = node.next;}n1 = node;n2 = head;// move node and n2 and the same timewhile (node.next != null) { node = node.next; n2 = n2.next;}// swapint temp = n1.val;n1.val = n2.val;n2.val = temp;return head;","link":"/2021/01/21/1721-Swapping-Nodes-in-a-Linked-List/"},{"title":"1722. Minimize Hamming Distance After Swap Operations","text":"📦 Refresh Your MemoryGiven a source array and a target array with an allowedSwaps array where each allowedSwaps[i] = [ai, bi]. Find the minimum hamming distance after unlimited swaps. 📚 Key Notes The detail of how it swaps does not matter If we can swap [0, 1] and [1, 2], then we can rearrange [0, 1, 2] to everything we want. Similar question: 1202. Smallest String With Swaps Thus, union-find would be a good fit Steps: Union-find all connected indexes Count elements for each union-find group (we use Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; here) Scan the target, try to find the element in that union-find group greedily if found: count - 1 if not: diff + 1 💻 Codepublic int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int N = source.length; int[] UNION = new int[N]; for (int i = 0; i &lt; N; ++i) UNION[i] = i; // union-find for (int[] swap : allowedSwaps) { int indexA = swap[0], indexB = swap[1]; int parentA = find(UNION, indexA), parentB = find(UNION, indexB); if (parentA != parentB) UNION[parentA] = parentB; } // count element for each union-find root: key: root of each union group, value: map Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; N; ++i) { int num = source[i]; int root = find(UNION, i); map.putIfAbsent(root, new HashMap&lt;&gt;()); Map&lt;Integer, Integer&gt; store = map.get(root); store.put(num, store.getOrDefault(num, 0) + 1); } // greedy fit the target, if not, diff++ int res = 0; for (int i = 0; i &lt; N; ++i) { int num = target[i]; int root = find(UNION, i); Map&lt;Integer, Integer&gt; store = map.get(root); if (store.getOrDefault(num, 0) == 0) res++; else store.put(num, store.get(num) - 1); } return res;}// union-find helperprivate int find(int[] UNION, int node) { if (UNION[node] == node) return node; return UNION[node] = find(UNION, UNION[node]);} 🎉 ThoughtsThis kind of unlimited swaps, steps, etc problems (do not care the process but result) ususally can be solved by union-find.","link":"/2021/01/21/1722-Minimize-Hamming-Distance-After-Swap-Operations/"},{"title":"1723. Find Minimum Time to Finish All Jobs","text":"📦 Refresh Your MemoryYou are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job. And given the k workers, return the minimum possible maximum working time of any assignment. 📚 Key Notes Classic DP problem, can be solved easily by using top-down dp (dfs + memo) BUT we need some optimizations to avoid TLE It is a common technique called “symmetry breaking”. (1) Pick the biggest job first (2) If current max is larger than our res, just exit peacefully (3) If multiple workers have the same values, assigning current job to either one has the same effect. Apart from the dp solution, we could also do it with binary search. We will search minimum time result from 0 to sum(jobs) (means: assign all jobs to single one worker, brutal). When doing the valid check: we need to do it recursively. Try to assign each job to each worker (something like permutation). 💻 CodeDP Solutionint res = Integer.MAX_VALUE; public int minimumTimeRequired(int[] jobs, int k) { Arrays.sort(jobs); helper(jobs, jobs.length - 1, new int[k]); return res;}private void helper(int[] jobs, int index, int[] sum) { if (index &lt; 0) { res = Math.min(res, Arrays.stream(sum).max().getAsInt()); return; } if (Arrays.stream(sum).max().getAsInt() &gt;= res) return; // early exit for (int i = 0; i &lt; sum.length; ++i) { if (i &gt; 0 &amp;&amp; sum[i] == sum[i - 1]) continue; // only search 1 sum[i] += jobs[index]; helper(jobs, index - 1, sum); sum[i] -= jobs[index]; }} Binary Search Solutionpublic int minimumTimeRequired(int[] jobs, int k) { Arrays.sort(jobs); int res = -1; int l = 0, r = Arrays.stream(jobs).sum(); while (l &lt;= r) { int m = (r - l) / 2 + l; int[] sum = new int[k]; if (isValid(jobs, sum, m, 0)) { res = m; r = m - 1; } else { l = m + 1; } } return res;}private boolean isValid(int[] jobs, int[] sum, int target, int index) { if (index == jobs.length) return true; for (int i = 0; i &lt; sum.length; ++i) { sum[i] += jobs[index]; if (sum[i] &lt;= target &amp;&amp; isValid(jobs, sum, target, index + 1)) return true; sum[i] -= jobs[index]; if (sum[i] == 0) break; // 0 is not possible, then no need to check anymore } return false;} 🎉 ThoughtsWhen doing hard dp problem, apart from dfs/memo, think about more optimizations like sorting, cut branch, etc.","link":"/2021/01/21/1723-Find-Minimum-Time-to-Finish-All-Jobs/"},{"title":"1726. Tuple with Same Product","text":"📦 Refresh Your MemoryGiven an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d. 📚 Key Notes Naive way is O(N^4), just try each tuple and check. Based on the data constraints, will TLE. Further more, we could do it in O(N^3) by sorting, somehome like binary search, but still will TLE as expected. By fixing two points (one tuple), we use two pointers to shrink and keep searching the other tuple. if l * r is larger than the product of two points, shrink r. Otherwise, move l. Based on the description, every element is distinct: we could simply use map and count tuple product and its frequency, which leads to the O(N^2) solution. If tuple (a, b) and (c, d) both have the same product: that means a, b, c, d they are all different for sure. Based on this, we could pre-compute the map first to get product with frequency, and then, go through every map entry to calculate the result. Here, we use math to calculate that: (1 + 2 + 3 + … + n) = (1 + n) * n / 2 💻 CodeO(N^3) Solutionint N = nums.length;Arrays.sort(nums);int res = 0;for (int i = 0; i &lt; N; ++i) { for (int j = N - 1; j &gt;= i + 3; --j) { int product = nums[i] * nums[j]; int l = i + 1, r = j - 1; while (l &lt; r) { int value = nums[l] * nums[r]; if (value == product) { ++l; --r; res += 8; } else if (value &gt; product) --r; else ++l; } }}return res; O(N^2) SolutionMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();int N = nums.length;for (int i = 0; i &lt; N; ++i) { for (int j = i + 1; j &lt; N; ++j) { int p = nums[i] * nums[j]; map.put(p, map.getOrDefault(p, 0) + 1); }}int res = 0;for (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) { if (e.getValue() &lt;= 1) continue; int count = e.getValue(); res += (8 * ((1 + count - 1) * (count - 1) / 2));}return res; 🎉 Thoughts Check the data constrains first to have a general idea, what time complexity is required.","link":"/2021/01/18/1726-Tuple-with-Same-Product/"},{"title":"1727. Largest Submatrix With Rearrangements","text":"📦 Refresh Your MemoryYou are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order. Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally. 📚 Key Notes These kinds of problems(binary matrix, submatrix area, etc) can generally be solved by trying just all possibilities. We could try to search for every down-side row (底边). For each down-side row, we can first calculate the histogram for this row. Then, a simple sort will solve the problem. Once sorting the histogram, for each histogram column, the area it can form is: Height: the value of the histogram column Width: N - the index of the histogram column The best way to think about this question is to draw. 💻 Codeint M = matrix.length, N = matrix[0].length; int[] A = new int[N]; // histogramint res = 0;for (int down = 0; down &lt; M; ++down) { // compute histogram for this down-side row for (int j = 0; j &lt; N; ++j) { A[j] = matrix[down][j] == 1 ? A[j] + 1 : 0; } // sort and compute max int[] B = Arrays.copyOf(A, A.length); Arrays.sort(B); for (int k = 0; k &lt; N; ++k) { int area = B[k] * (N - k); // B[k]: height, (N - k): width res = Math.max(res, area); }}return res; 🎉 Thoughts Largest area, submetrix, histogram…拿到类似的题目就去想一想up/down row试每一种可能性这种方法。","link":"/2021/01/18/1727-Largest-Submatrix-With-Rearrangements/"},{"title":"1728. Cat and Mouse II","text":"📦 Refresh Your MemoryA game is played by a cat and a mouse named Cat and Mouse with some rules and constraints. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. 📚 Key Notes DFS/Memo part is simple. Just follow the standard of the top down dp. We should distinguish the turn for mouse and cat. For mouse: we are trying to find a way to win -&gt; if there is a true, we just return true For cat: we are trying to find a way to not let mouse win -&gt; if there is a false, we just return false. And, we have 5 variables in dfs, thus, create a 5D DP to memo it. The key to pass this question is: there is a case, cat and mouse they both can not proceed (live lock). Based on some tests, this magic number is 68. That means, if we run over 68 times, cat wins! 💻 Codeprivate char[][] A; private int M, N;private int[] dirs = new int[] {1, 0, -1, 0, 1};private int maxCat, maxMouse;private int MAGIC_NUMBER = 68;public boolean canMouseWin(String[] grid, int catJump, int mouseJump) { M = grid.length; N = grid[0].length(); A = new char[M][N]; maxCat = catJump; maxMouse = mouseJump; for (int i = 0; i &lt; M; ++i) { A[i] = grid[i].toCharArray(); } int[] catPos = new int[2]; int[] mousePos = new int[2]; for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { if (A[i][j] == 'C') catPos = new int[] {i, j}; if (A[i][j] == 'M') mousePos = new int[] {i, j}; } } return helper(catPos[0], catPos[1], mousePos[0], mousePos[1], 0, new Boolean[8][8][8][8][MAGIC_NUMBER]);}// helper means: does mouse win?private boolean helper(int cx, int cy, int mx, int my, int turn, Boolean[][][][][] dp) { // the game will ends in ~ 68 rounds, let's safe it to 200 rounds if (turn &gt;= MAGIC_NUMBER) return false; if (mx == cx &amp;&amp; my == cy) return false; // memo cache if (dp[cx][cy][mx][my][turn] != null) return dp[cx][cy][mx][my][turn]; boolean res = !(turn % 2 == 0); // trick point if (turn % 2 == 0) { // mouse turn for (int d = 0; d &lt; 4; ++d) { if (res) break; for (int jump = 0; jump &lt;= maxMouse; ++jump) { int nx = mx + dirs[d] * jump; int ny = my + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = true; break; } if (helper(cx, cy, nx, ny, turn + 1, dp)) { res = true; break; } } } } else { // cat turn for (int d = 0; d &lt; 4; ++d) { if (!res) break; for (int jump = 0; jump &lt;= maxCat; ++jump) { int nx = cx + dirs[d] * jump; int ny = cy + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = false; break; } if (!helper(nx, ny, mx, my, turn + 1, dp)) { res = false; break; } } } } return dp[cx][cy][mx][my][turn] = res;}","link":"/2021/01/18/1728-Cat-and-Mouse-II/"}],"tags":[{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Hard","slug":"Hard","link":"/tags/Hard/"},{"name":"BIT","slug":"BIT","link":"/tags/BIT/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Union Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Histogram","slug":"Histogram","link":"/tags/Histogram/"},{"name":"DFS&#x2F;Memo","slug":"DFS-Memo","link":"/tags/DFS-Memo/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}