{"pages":[{"title":"","text":"🎉 只是为了记录 Just for Recording 一个简单的Blog，记录一些LeetCode题目的思路，希望能帮助到需要帮助的人。 A simple blog just for recording some LeetCode questions, hope it helps.","link":"/about/index.html"}],"posts":[{"title":"1707. Maximum XOR With an Element From Array","text":"📦 Refresh Your MemoryGiven an number array, and a bunch of queries. The answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. Return an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query. 📚 Key Notes Before doing this one, you should solve 421 first. Then, things get easier with Trie: Sort the queries based on m Keep inserting numbers below m Retrieve max XOR on x from Trie 💻 Codeclass TrieNode { TrieNode[] children = new TrieNode[2];}public int[] maximizeXor(int[] nums, int[][] queries) { int[][] Q = new int[queries.length][3]; for (int i = 0; i &lt; queries.length; ++i) { Q[i][0] = queries[i][0]; Q[i][1] = queries[i][1]; Q[i][2] = i; } Arrays.sort(nums); Arrays.sort(Q, (a, b) -&gt; (a[1] - b[1])); int j = 0; TrieNode root = new TrieNode(); int[] res = new int[queries.length]; Arrays.fill(res, -1); for (int i = 0; i &lt; queries.length; ++i) { int x = Q[i][0]; int m = Q[i][1]; for (; j &lt; nums.length &amp;&amp; nums[j] &lt;= m; ++j) { // insert into trie insertIntoTrie(root, nums[j]); } // get max xor on x res[Q[i][2]] = getMaxXOR(root, x); } return res;}private int getMaxXOR(TrieNode root, int x) { TrieNode node = root; int res = 0; for (int i = 31; i &gt;= 0; --i) { res &lt;&lt;= 1; int oppositeBit = ((x &gt;&gt;&gt; i) &amp; 1) ^ 1; if (node.children[0] == null &amp;&amp; node.children[1] == null) return -1; if (node.children[oppositeBit] == null) node = node.children[oppositeBit ^ 1]; else { res += 1; node = node.children[oppositeBit]; } } return res;}private void insertIntoTrie(TrieNode root, int num) { TrieNode node = root; for (int i = 31; i &gt;= 0; --i) { int bit = (num &gt;&gt;&gt; i) &amp; 1; if (node.children[bit] == null) node.children[bit] = new TrieNode(); node = node.children[bit]; }} 🎉 ThoughtsWith the fixed queries, we could sort it and build our Trie on the fly. It is quite a common technique to solve query-like question.","link":"/2021/01/25/1707-Maximum-XOR-With-an-Element-From-Array/"},{"title":"1706. Where Will the Ball Fall","text":"📦 Refresh Your MemoryGiven a 2-D grid, and with some diagonal boards spanning two corners of the cell that can redirect a ball to the right or to the left. Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box. 📚 Key Notes Classic DFS/DP problem, we can further add memo (cache) to avoid repeatness. For each cell, the ball can come from 3 directions: top, left and right. That means: we need to introduce a code to distinguish them 0: from top, 1: -&gt; from left, 2: &lt;- from right Based on the code, just simple logic. 💻 Codepublic int[] findBall(int[][] grid) { int M = grid.length, N = grid[0].length; int[][][] cache = new int[M][N][3]; for (int i = 0; i &lt; cache.length; ++i) { for (int j = 0; j &lt; cache[i].length; ++j) Arrays.fill(cache[i][j], N); } int[] res = new int[N]; for (int column = 0; column &lt; N; ++column) { res[column] = helper(grid, 0, column, 0, cache, M, N); } return res;}/* return: -1: stuck or column index 0: from top, 1: -&gt; from left, 2: &lt;- from right cache: N (init value), 0 ~ N - 1*/private int helper(int[][] grid, int x, int y, int code, int[][][] cache, int M, int N) { // out of bound check if (x &lt; 0 || x &gt;= M || y &lt; 0 || y &gt;= N) { if (code == 0 &amp;&amp; x == M &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; N) return y; // OK else return -1; // stuck } if (cache[x][y][code] != N) return cache[x][y][code]; int res = -1; if (grid[x][y] == 1) { if (code == 0) res = helper(grid, x, y + 1, 1, cache, M, N); if (code == 1) res = helper(grid, x + 1, y, 0, cache, M, N); if (code == 2) res = -1; } else { if (code == 0) res = helper(grid, x, y - 1, 2, cache, M, N); if (code == 1) res = -1; if (code == 2) res = helper(grid, x + 1, y, 0, cache, M, N);; } return cache[x][y][code] = res;} 🎉 ThoughtsThis solution is like expand the grid X 3. It is a common way to solve grid with various directions problem.","link":"/2021/01/25/1706-Where-Will-the-Ball-Fall/"},{"title":"1711. Count Good Meals","text":"📦 Refresh Your MemoryA good story, but it is just: giving an array, and return the number of different tuple (sum is power of 2) you can make from this list with MOD. 📚 Key Notes Firstly, check the data constraints: the sum of any two elements will be smaller than the Integer MAX. This kind of “Power of 2” problem usually can be solved with some O(32 Whatever) solution. That means: in terms of unsigned int, we only have 32 numbers which are power of two. Then, just search all of “power of 2” values with map (similar idea with two sum problem) 💻 Codeint MOD = (int) (1e9 + 7);int res = 0;for (int i = 0; i &lt; 32; ++i) { int target = 1 &lt;&lt; i; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int d : deliciousness) { if (target &gt;= d &amp;&amp; map.containsKey(target - d)) res = (res + map.get(target - d) % MOD) % MOD; map.put(d, map.getOrDefault(d, 0) + 1); }}return res; 🎉 ThoughtsWhen comes to power of 2, think about O(32 Whatever) solution.","link":"/2021/01/22/1711-Count-Good-Meals/"},{"title":"1712. Ways to Split Array Into Three Subarrays","text":"📦 Refresh Your MemorySplit an array to left, mid, and right with condition: the sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right. Return the number of good ways to split nums with MOD. 📚 Key Notes Naive solution would be: O(N^2), searching all two points, which separates leftSum, midSum and rightSum To quickly find the range sum, we will use prefix sum here (10^4 * 10^5 not out of bound of Integer, we good) By fixing one point (A), we could use binary search to find another point (B). If the point B is too left, the midSum will be too small If the point B is too right, the rightSum will be too small Basically, we are finding a range of the point B, which satisfies the condition (leftSum &lt;= midSum &lt;= rightSum) Similar the to question 34. Find First and Last Position of Element in Sorted Array 💻 Codepublic int waysToSplit(int[] nums) { int MOD = (int) (1e9 + 7); int N = nums.length; // prefix array int[] A = new int[N]; A[0] = nums[0]; for (int i = 1; i &lt; N; ++i) A[i] = A[i - 1] + nums[i]; int res = 0; for (int i = 1; i &lt; N - 1; ++i) { if (A[i - 1] &gt; (A[N - 1] - A[i - 1]) / 2) break; // early termination int left = helper(A, A[i - 1], i, true); int right = helper(A, A[i - 1], i, false); if (left == -1 || right == -1) continue; // none is satisfied res = (res + (right - left + 1) % MOD) % MOD; } return res;}private int helper(int[] A, int leftSum, int index, boolean searchLeft) { int N = A.length; int l = index, r = N - 2; int res = -1; while (l &lt;= r) { int m = (r - l) / 2 + l; int midSum = A[m] - A[index - 1]; int rightSum = A[N - 1] - A[m]; if (leftSum &lt;= midSum &amp;&amp; midSum &lt;= rightSum) { res = m; if (searchLeft) r = m - 1; else l = m + 1; } else if (leftSum &gt; midSum) { // shrink left l = m + 1; } else { // shrink right r = m - 1; } } return res;} 🎉 ThoughtsFrom naive to fairly good.","link":"/2021/01/22/1712-Ways-to-Split-Array-Into-Three-Subarrays/"},{"title":"1713. Minimum Operations to Make a Subsequence","text":"📦 Refresh Your MemoryYou are given an array target that consists of distinct integers and another integer array arr that can have duplicates. Keep inserting any element at any position into arr. Return the minimum number of operations needed to make target a subsequence of arr. 📚 Key Notes The problem seems like a LIS (longest increasing subsequence) problem, and it is. But based on the data constraints: O(N^2) will not be acceptable There are two ways to solve this problem: O(NlogN) LIS Solution, you could find it on LeetCode BIT (Binary Indexed Tree/Fenwich Tree) By using BIT, at each element of arr, we are looking for the longest subsequence value from its previous index. Normally, there are two methods for BIT: update and getPrefix. Just need to slightly modify both of them: not get sum but look for max. 💻 Codepublic int minOperations(int[] target, int[] arr) { int M = target.length, N = arr.length; int[] BIT = new int[M + 1]; // 1: index Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; M; ++i) { map.put(target[i], i); } int res = 0; for (int a : arr) { if (!map.containsKey(a)) continue; int index = map.get(a); int cur = getPreMax(BIT, index); cur++; res = Math.max(res, cur); update(BIT, index + 1, cur); } return M - res;}private void update(int[] BIT, int index, int val) { while (index &lt; BIT.length) { BIT[index] = Math.max(val, BIT[index]); index += index &amp; (-index); }}private int getPreMax(int[] BIT, int index) { int res = 0; while (index &gt; 0) { res = Math.max(res, BIT[index]); index -= index &amp; (-index); } return res;} 🎉 ThoughtsBIT usually works for finding range sun with frequent updates. But here, we are turning it to find max with frequent updates. It is just a derivative of BIT.","link":"/2021/01/22/1713-Minimum-Operations-to-Make-a-Subsequence/"},{"title":"1721. Swapping Nodes in a Linked List","text":"📦 Refresh Your MemoryYou are given the head of a linked list, and an integer k. Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed). 📚 Key Notes 3 passes solution is easy, find the Kth, find the N-Kth, and swap the values. 1 pass solution: Something like two pointers, put we actually move two pointers together. Find the k-th node, set a pointer (n2), and set another pointer at the head (n1) Move two pointers together until reaching the end. n1 and n2 are the onces we are looking for! 💻 CodeListNode n1 = null, n2 = null;ListNode node = head;// find the k-thfor (int i = 1; i &lt; k; ++i) { node = node.next;}n1 = node;n2 = head;// move node and n2 and the same timewhile (node.next != null) { node = node.next; n2 = n2.next;}// swapint temp = n1.val;n1.val = n2.val;n2.val = temp;return head;","link":"/2021/01/21/1721-Swapping-Nodes-in-a-Linked-List/"},{"title":"1722. Minimize Hamming Distance After Swap Operations","text":"📦 Refresh Your MemoryGiven a source array and a target array with an allowedSwaps array where each allowedSwaps[i] = [ai, bi]. Find the minimum hamming distance after unlimited swaps. 📚 Key Notes The detail of how it swaps does not matter If we can swap [0, 1] and [1, 2], then we can rearrange [0, 1, 2] to everything we want. Similar question: 1202. Smallest String With Swaps Thus, union-find would be a good fit Steps: Union-find all connected indexes Count elements for each union-find group (we use Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; here) Scan the target, try to find the element in that union-find group greedily if found: count - 1 if not: diff + 1 💻 Codepublic int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int N = source.length; int[] UNION = new int[N]; for (int i = 0; i &lt; N; ++i) UNION[i] = i; // union-find for (int[] swap : allowedSwaps) { int indexA = swap[0], indexB = swap[1]; int parentA = find(UNION, indexA), parentB = find(UNION, indexB); if (parentA != parentB) UNION[parentA] = parentB; } // count element for each union-find root: key: root of each union group, value: map Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; N; ++i) { int num = source[i]; int root = find(UNION, i); map.putIfAbsent(root, new HashMap&lt;&gt;()); Map&lt;Integer, Integer&gt; store = map.get(root); store.put(num, store.getOrDefault(num, 0) + 1); } // greedy fit the target, if not, diff++ int res = 0; for (int i = 0; i &lt; N; ++i) { int num = target[i]; int root = find(UNION, i); Map&lt;Integer, Integer&gt; store = map.get(root); if (store.getOrDefault(num, 0) == 0) res++; else store.put(num, store.get(num) - 1); } return res;}// union-find helperprivate int find(int[] UNION, int node) { if (UNION[node] == node) return node; return UNION[node] = find(UNION, UNION[node]);} 🎉 ThoughtsThis kind of unlimited swaps, steps, etc problems (do not care the process but result) ususally can be solved by union-find.","link":"/2021/01/21/1722-Minimize-Hamming-Distance-After-Swap-Operations/"},{"title":"1723. Find Minimum Time to Finish All Jobs","text":"📦 Refresh Your MemoryYou are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job. And given the k workers, return the minimum possible maximum working time of any assignment. 📚 Key Notes Classic DP problem, can be solved easily by using top-down dp (dfs + memo) BUT we need some optimizations to avoid TLE It is a common technique called “symmetry breaking”. (1) Pick the biggest job first (2) If current max is larger than our res, just exit peacefully (3) If multiple workers have the same values, assigning current job to either one has the same effect. Apart from the dp solution, we could also do it with binary search. We will search minimum time result from 0 to sum(jobs) (means: assign all jobs to single one worker, brutal). When doing the valid check: we need to do it recursively. Try to assign each job to each worker (something like permutation). 💻 CodeDP Solutionint res = Integer.MAX_VALUE; public int minimumTimeRequired(int[] jobs, int k) { Arrays.sort(jobs); helper(jobs, jobs.length - 1, new int[k]); return res;}private void helper(int[] jobs, int index, int[] sum) { if (index &lt; 0) { res = Math.min(res, Arrays.stream(sum).max().getAsInt()); return; } if (Arrays.stream(sum).max().getAsInt() &gt;= res) return; // early exit for (int i = 0; i &lt; sum.length; ++i) { if (i &gt; 0 &amp;&amp; sum[i] == sum[i - 1]) continue; // only search 1 sum[i] += jobs[index]; helper(jobs, index - 1, sum); sum[i] -= jobs[index]; }} Binary Search Solutionpublic int minimumTimeRequired(int[] jobs, int k) { Arrays.sort(jobs); int res = -1; int l = 0, r = Arrays.stream(jobs).sum(); while (l &lt;= r) { int m = (r - l) / 2 + l; int[] sum = new int[k]; if (isValid(jobs, sum, m, 0)) { res = m; r = m - 1; } else { l = m + 1; } } return res;}private boolean isValid(int[] jobs, int[] sum, int target, int index) { if (index == jobs.length) return true; for (int i = 0; i &lt; sum.length; ++i) { sum[i] += jobs[index]; if (sum[i] &lt;= target &amp;&amp; isValid(jobs, sum, target, index + 1)) return true; sum[i] -= jobs[index]; if (sum[i] == 0) break; // 0 is not possible, then no need to check anymore } return false;} 🎉 ThoughtsWhen doing hard dp problem, apart from dfs/memo, think about more optimizations like sorting, cut branch, etc.","link":"/2021/01/21/1723-Find-Minimum-Time-to-Finish-All-Jobs/"},{"title":"1727. Largest Submatrix With Rearrangements","text":"📦 Refresh Your MemoryYou are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order. Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally. 📚 Key Notes These kinds of problems(binary matrix, submatrix area, etc) can generally be solved by trying just all possibilities. We could try to search for every down-side row (底边). For each down-side row, we can first calculate the histogram for this row. Then, a simple sort will solve the problem. Once sorting the histogram, for each histogram column, the area it can form is: Height: the value of the histogram column Width: N - the index of the histogram column The best way to think about this question is to draw. 💻 Codeint M = matrix.length, N = matrix[0].length; int[] A = new int[N]; // histogramint res = 0;for (int down = 0; down &lt; M; ++down) { // compute histogram for this down-side row for (int j = 0; j &lt; N; ++j) { A[j] = matrix[down][j] == 1 ? A[j] + 1 : 0; } // sort and compute max int[] B = Arrays.copyOf(A, A.length); Arrays.sort(B); for (int k = 0; k &lt; N; ++k) { int area = B[k] * (N - k); // B[k]: height, (N - k): width res = Math.max(res, area); }}return res; 🎉 Thoughts Largest area, submetrix, histogram…拿到类似的题目就去想一想up/down row试每一种可能性这种方法。","link":"/2021/01/18/1727-Largest-Submatrix-With-Rearrangements/"},{"title":"1726. Tuple with Same Product","text":"📦 Refresh Your MemoryGiven an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d. 📚 Key Notes Naive way is O(N^4), just try each tuple and check. Based on the data constraints, will TLE. Further more, we could do it in O(N^3) by sorting, somehome like binary search, but still will TLE as expected. By fixing two points (one tuple), we use two pointers to shrink and keep searching the other tuple. if l * r is larger than the product of two points, shrink r. Otherwise, move l. Based on the description, every element is distinct: we could simply use map and count tuple product and its frequency, which leads to the O(N^2) solution. If tuple (a, b) and (c, d) both have the same product: that means a, b, c, d they are all different for sure. Based on this, we could pre-compute the map first to get product with frequency, and then, go through every map entry to calculate the result. Here, we use math to calculate that: (1 + 2 + 3 + … + n) = (1 + n) * n / 2 💻 CodeO(N^3) Solutionint N = nums.length;Arrays.sort(nums);int res = 0;for (int i = 0; i &lt; N; ++i) { for (int j = N - 1; j &gt;= i + 3; --j) { int product = nums[i] * nums[j]; int l = i + 1, r = j - 1; while (l &lt; r) { int value = nums[l] * nums[r]; if (value == product) { ++l; --r; res += 8; } else if (value &gt; product) --r; else ++l; } }}return res; O(N^2) SolutionMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();int N = nums.length;for (int i = 0; i &lt; N; ++i) { for (int j = i + 1; j &lt; N; ++j) { int p = nums[i] * nums[j]; map.put(p, map.getOrDefault(p, 0) + 1); }}int res = 0;for (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) { if (e.getValue() &lt;= 1) continue; int count = e.getValue(); res += (8 * ((1 + count - 1) * (count - 1) / 2));}return res; 🎉 Thoughts Check the data constrains first to have a general idea, what time complexity is required.","link":"/2021/01/18/1726-Tuple-with-Same-Product/"},{"title":"1728. Cat and Mouse II","text":"📦 Refresh Your MemoryA game is played by a cat and a mouse named Cat and Mouse with some rules and constraints. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. 📚 Key Notes DFS/Memo part is simple. Just follow the standard of the top down dp. We should distinguish the turn for mouse and cat. For mouse: we are trying to find a way to win -&gt; if there is a true, we just return true For cat: we are trying to find a way to not let mouse win -&gt; if there is a false, we just return false. And, we have 5 variables in dfs, thus, create a 5D DP to memo it. The key to pass this question is: there is a case, cat and mouse they both can not proceed (live lock). Based on some tests, this magic number is 68. That means, if we run over 68 times, cat wins! 💻 Codeprivate char[][] A; private int M, N;private int[] dirs = new int[] {1, 0, -1, 0, 1};private int maxCat, maxMouse;private int MAGIC_NUMBER = 68;public boolean canMouseWin(String[] grid, int catJump, int mouseJump) { M = grid.length; N = grid[0].length(); A = new char[M][N]; maxCat = catJump; maxMouse = mouseJump; for (int i = 0; i &lt; M; ++i) { A[i] = grid[i].toCharArray(); } int[] catPos = new int[2]; int[] mousePos = new int[2]; for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { if (A[i][j] == 'C') catPos = new int[] {i, j}; if (A[i][j] == 'M') mousePos = new int[] {i, j}; } } return helper(catPos[0], catPos[1], mousePos[0], mousePos[1], 0, new Boolean[8][8][8][8][MAGIC_NUMBER]);}// helper means: does mouse win?private boolean helper(int cx, int cy, int mx, int my, int turn, Boolean[][][][][] dp) { // the game will ends in ~ 68 rounds, let's safe it to 200 rounds if (turn &gt;= MAGIC_NUMBER) return false; if (mx == cx &amp;&amp; my == cy) return false; // memo cache if (dp[cx][cy][mx][my][turn] != null) return dp[cx][cy][mx][my][turn]; boolean res = !(turn % 2 == 0); // trick point if (turn % 2 == 0) { // mouse turn for (int d = 0; d &lt; 4; ++d) { if (res) break; for (int jump = 0; jump &lt;= maxMouse; ++jump) { int nx = mx + dirs[d] * jump; int ny = my + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = true; break; } if (helper(cx, cy, nx, ny, turn + 1, dp)) { res = true; break; } } } } else { // cat turn for (int d = 0; d &lt; 4; ++d) { if (!res) break; for (int jump = 0; jump &lt;= maxCat; ++jump) { int nx = cx + dirs[d] * jump; int ny = cy + dirs[d + 1] * jump; if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || A[nx][ny] == '#') break; if (A[nx][ny] == 'F') { res = false; break; } if (!helper(nx, ny, mx, my, turn + 1, dp)) { res = false; break; } } } } return dp[cx][cy][mx][my][turn] = res;}","link":"/2021/01/18/1728-Cat-and-Mouse-II/"},{"title":"1737. Change Minimum Characters to Satisfy One of Three Conditions","text":"📦 Refresh Your MemoryHaving 2 strings a and b, you can change any character in a or b to any lowercase letter. The goal is to satisfy one of three conditions. Return the minimum number of operations needed to achieve your goal. 📚 Key Notes Condition 1 and condition 2 are symmetrical, so generally we have 2 operations: make a below b and make a and b only one distince letter. Operation 1 =&gt; make a below b: We don’t need to care how we make it, but there is definately a character, which separates the string a and string b We can try this boundaray chararacter from b to z, and see how many steps to make string a below it, how many steps to make string b above or equal it. And just return the smallest steps among all boundary characters. Operation 2 =&gt; make a and b only one distince letter: We just need to count the most frequent character of string(a + b) The operation we need to take is: a.length() + b.length() - count 💻 Codepublic int minCharacters(String a, String b) { return Math.min(Math.min(operation1(a, b), operation1(b, a)), operation2(a, b));}// operation to make a below bprivate int operation1(String a, String b) { int res = Integer.MAX_VALUE; for (int i = 1; i &lt; 26; ++i) { int count = 0; for (char c : a.toCharArray()) { if ((c - 'a') &gt;= i) ++count; } for (char c : b.toCharArray()) { if ((c - 'a') &lt; i) ++count; } res = Math.min(res, count); } return res;}// operation to make only one distinct letterprivate int operation2(String a, String b) { int[] A = new int[26]; for (char c : a.toCharArray()) A[c - 'a']++; for (char c : b.toCharArray()) A[c - 'a']++; int res = 0; for (int i = 0; i &lt; 26; ++i) { res = Math.max(res, A[i]); } return a.length() + b.length() - res;} 🎉 ThoughtsDon’t struggle into the proces but think about the result.","link":"/2021/01/23/1737-Change-Minimum-Characters-to-Satisfy-One-of-Three-Conditions/"},{"title":"1738. Find Kth Largest XOR Coordinate Value","text":"📦 Refresh Your MemoryGiven a matrix and define a XOR operation. Find the kth largest value (1-indexed) of all the coordinates of matrix. 📚 Key Notes Firstly, you need to know: a ^ b ^ a = b Then: see the graph below: dp[i][j] means XOR of from 0 to i and 0 to j To calculate dp[i][j] at point D dp[i - 1][j] = (A ^ C), dp[i][j - 1] = (A ^ B) dp[i - 1][j] ^ dp[i][j - 1] = A ^ C ^ A ^ B = B ^ C dp[i - 1][j] ^ dp[i][j - 1] ^ dp[i - 1][j - 1] = B ^ C ^ A dp[i - 1][j] ^ dp[i][j - 1] ^ dp[i - 1][j - 1] ^ matrix[i][j] = dp[i][j] is the result we are looking for! 💻 Codeint M = matrix.length, N = matrix[0].length;int[][] dp = new int[M][N];PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { int x = (i - 1 &lt; 0 ? 0 : dp[i - 1][j]); int y = (j - 1 &lt; 0 ? 0 : dp[i][j - 1]); int z = (i - 1 &lt; 0 || j - 1 &lt; 0 ? 0 : dp[i - 1][j - 1]); dp[i][j] = (x ^ y ^ z ^ matrix[i][j]); pq.add(dp[i][j]); if (pq.size() &gt; k) pq.poll(); }}return pq.poll(); 🎉 ThoughtsFirstly, you should know the basic XOR rule a ^ b ^ a = b. Then, draw a picture is helpful!","link":"/2021/01/23/1738-Find-Kth-Largest-XOR-Coordinate-Value/"},{"title":"1739. Building Boxes","text":"📦 Refresh Your MemoryGiven n boxes, and You can place the boxes anywhere on the floor. If box x is placed on top of the box y, then each side of the four vertical sides of the box y must either be adjacent to another box or to a wall. return the minimum possible number of boxes touching the floor. 📚 Key Notes It is a triangle number problem. Before that, you need to know some equaltions: The n-th triangle number is: (n) * (n + 1) / 2 The sum of first n triangle numbers is: (n) * (n + 1) * (n + 2) / 6 First: find a complete triangle cone (complete means 1 3 6 10…) You can solve this cubic function by some math, but I am using binary search for simplicity. Remain boxes (R) need to be place as R + (R - 1) + (R - 2) + … just find this number R 💻 Codepublic int minimumBoxes(int n) { int l = 0, r = 2000; // magic number since n is &lt;= 10^9 int order = 0; // find a complete triangle cone (1 3 6 10 ...) while (l &lt;= r) { int m = (r - l) / 2 + l; int value = getTriangleTotal(m); if (value &gt; n) r = m - 1; else { order = m; l = m + 1; } } // order is the complete triangle-th int onFloor = (order) * (order + 1) / 2; int remainBoxes = n - getTriangleTotal(order); int remainOnFloor = (int) Math.ceil((-1 + Math.sqrt(1 + 8 * remainBoxes)) / 2.0); return onFloor + remainOnFloor;}private int getTriangleTotal(int n) { long x = n; return (int) ((x) * (x + 1) * (x + 2) / 6);}","link":"/2021/01/24/1739-Building-Boxes/"},{"title":"1743. Restore the Array From Adjacent Pairs","text":"📦 Refresh Your MemoryGiven a bunch of pairs, please restore the orginal array. 📚 Key Notes Just observe, you will find there are two elements which appear only once. Because they are head and tail. So, just follow the head, head to next one through pair, until reaching the end. We could use Set to check visited or just check if == previous. 💻 CodeMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();Set&lt;Integer&gt; set = new HashSet&lt;&gt;();for (int[] pair : adjacentPairs) { int a = pair[0], b = pair[1]; map.computeIfAbsent(a, f -&gt; new ArrayList&lt;&gt;()).add(b); map.computeIfAbsent(b, f -&gt; new ArrayList&lt;&gt;()).add(a);}int head = -1;for (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; e : map.entrySet()) { if (e.getValue().size() == 1) { head = e.getKey(); break; }}int[] res = new int[adjacentPairs.length + 1];for (int i = 0; i &lt; res.length; ++i) { res[i] = head; set.add(head); if (i == res.length - 1) break; if (!set.contains(map.get(head).get(0))) head = map.get(head).get(0); else head = map.get(head).get(1);}return res; 🎉 ThoughtsThere is another question related to restore original array, they both have the same idea (start from two special elements: head + tail).","link":"/2021/01/31/1743-Restore-the-Array-From-Adjacent-Pairs/"},{"title":"1744. Can You Eat Your Favorite Candy on Your Favorite Day?","text":"📦 Refresh Your MemoryGiven a candy array and queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]. Return true if you can eat favoriteType at favoriteDay without exceeding dailyCap. 📚 Key Notes The min speed is 1, the max speed is dailyCap. We don’t need to care about exactly how to eat, but just check if our favorite type is within that min-max range. How to quickly check that? O(NlogN) Solution: Prefix Sum TreeMap or Binary Search, we could find a lower type and a upper type. Then we just need to make sure our type is within this type range. O(N) Solution: Based on the min speed and max speed, we have total candies range We just need to check if this candies range covers our favourite type range. 💻 CodeO(NlogN) Solutionpublic boolean[] canEat(int[] candiesCount, int[][] queries) { int N = queries.length; boolean[] res = new boolean[N]; TreeMap&lt;Long, Integer&gt; map = new TreeMap&lt;&gt;(); long sum = 0; for (int i = 0; i &lt; candiesCount.length; ++i) { sum += candiesCount[i]; map.put(sum, i); } for (int i = 0; i &lt; N; ++i) { int day = queries[i][1] + 1; // find lower bound type int lowerType = helper(map, 1 * ((long) day)); if (lowerType == -1) { res[i] = false; continue; } // find upper bound type int upperType = helper(map, queries[i][2] * ((long) day)); if (upperType == -1) upperType = candiesCount.length - 1; int favoriteType = queries[i][0]; // System.out.println(&quot;query: &quot; + i + &quot;, lower: &quot; + lowerType + &quot;, upper: &quot; + upperType + &quot;, ft: &quot; + queries[i][0] + &quot;, fd: &quot; + queries[i][1] + &quot;, dc: &quot; + queries[i][2]); res[i] = (favoriteType &gt;= lowerType &amp;&amp; favoriteType &lt;= upperType); } return res;}private int helper(TreeMap&lt;Long, Integer&gt; map, long sum) { Long key = map.ceilingKey(sum); if (key == null) return -1; return map.get(key);} O(N) Solutionint N = queries.length;boolean[] res = new boolean[N];long[] A = new long[candiesCount.length];A[0] = candiesCount[0];for (int i = 1; i &lt; candiesCount.length; ++i) { A[i] = A[i - 1] + candiesCount[i];}for (int i = 0; i &lt; N; ++i) { int numberOfDays = queries[i][1] + 1; // day is 0 index int fType = queries[i][0]; long lower = (fType - 1 &lt; 0 ? 0 : A[fType - 1]) + 1; long upper = A[fType]; res[i] = true; if ((1 * ((long) numberOfDays)) &gt; upper) res[i] = false; if ((queries[i][2] * ((long) numberOfDays)) &lt; lower) res[i] = false;}return res; 🎉 ThoughtsTypical prefix sum question. Still, do not need to care about process but result.","link":"/2021/01/31/1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day/"},{"title":"421. Maximum XOR of Two Numbers in an Array","text":"📦 Refresh Your MemoryGiven an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 ≤ i ≤ j &lt; n. 📚 Key Notes Keep in mind the characteristic of XOR: 1 ^ 0 = 1, 0 ^ 1 = 1. That means: we are trying to look for two numbers with maximum opposite bit pairs. If a bit of number A is 0, then we are trying to look for a bit of number B is 1. In this way, we can make this resulted bit 1 after XOR. But, we need to do that from MSB to LSB. There are 32 bits totally for each number. So, we can build Trie for all of them. Children of each trie node are 0 and 1. After building Trie, for each number, start from root node to end, and try to find the max result. 💻 Codeclass TrieNode { TrieNode[] children = new TrieNode[2];}public int findMaximumXOR(int[] nums) { TrieNode root = new TrieNode(); for (int num : nums) { TrieNode node = root; for (int i = 31; i &gt;= 0; --i) { int bit = (num &gt;&gt;&gt; i) &amp; 1; if (node.children[bit] == null) node.children[bit] = new TrieNode(); node = node.children[bit]; } } int res = Integer.MIN_VALUE; for (int num : nums) { TrieNode node = root; int currRes = 0; for (int i = 31; i &gt;= 0; --i) { currRes &lt;&lt;= 1; int oppositeBit = ((num &gt;&gt;&gt; i) &amp; 1) ^ 1; if (node.children[oppositeBit] == null) node = node.children[oppositeBit ^ 1]; else { currRes += 1; node = node.children[oppositeBit]; } } res = Math.max(res, currRes); } return res;} 🎉 ThoughtsIt is a good practice of Trie. It is quite hard, if you see it at the first time.","link":"/2021/01/25/421-Maximum-XOR-of-Two-Numbers-in-an-Array/"},{"title":"1745. Palindrome Partitioning IV","text":"📦 Refresh Your MemoryGiven a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.​​​​​ 📚 Key NotesKey Notes: The length of the string is 2000, it indicates that an O(N^2) solution could pass easily Firstly, use O(N^2) to build a palindrom quick look-up table This quick look-up table will tell us, if substring[i, j] is a palindrome in O(1) (We could use DP to do that) For the problem if substring[i, j] is palindrome: If char(i) == char(j), we can reduce the problem to a subproblem “if substring[i + 1, j - 1] is palindrome“ If char(i) != char(j), simply set it to false Next, use O(N^2) to iterate every mid part substring We can now check, if left, mid and right are all palindrom, and return true. 💻 Codeint N = s.length();char[] A = s.toCharArray();// build dp tableboolean[][] dp = new boolean[N][N];for (int i = N - 1; i &gt;= 0; --i) { for (int j = i; j &lt; N; ++j) { if (A[i] == A[j]) dp[i][j] = ((i + 1 &lt;= j - 1) ? dp[i + 1][j - 1] : true); else dp[i][j] = false; }}// iterate every mid and then check: left, mid and rightfor (int i = 1; i &lt; N - 1; ++i) { for (int j = i; j &lt; N - 1; ++j) { if (dp[0][i - 1] &amp;&amp; dp[i][j] &amp;&amp; dp[j + 1][N - 1]) return true; }}return false;","link":"/2021/01/31/1745-Palindrome-Partitioning-IV/"}],"tags":[{"name":"Hard","slug":"Hard","link":"/tags/Hard/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","link":"/tags/Bit-Manipulation/"},{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"BIT","slug":"BIT","link":"/tags/BIT/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Union Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Histogram","slug":"Histogram","link":"/tags/Histogram/"},{"name":"DFS&#x2F;Memo","slug":"DFS-Memo","link":"/tags/DFS-Memo/"},{"name":"Ad Hoc","slug":"Ad-Hoc","link":"/tags/Ad-Hoc/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Prefix Sum","slug":"Prefix-Sum","link":"/tags/Prefix-Sum/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}